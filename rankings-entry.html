<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Justin Boone Rankings Entry</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .position-section { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
        .position-section h3 { margin-top: 0; color: #4a00e0; }
        textarea { width: 100%; height: 150px; font-family: monospace; }
        button { background: #4a00e0; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; margin: 5px; }
        button:hover { background: #6a20e0; }
        .output { background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; }
        .instructions { background: #e8f4f8; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
    </style>
</head>
<body>
    <h1>üìä Justin Boone Rankings Entry</h1>
    
    <!-- URL Monitor Section -->
    <div class="position-section" style="background: #fff3cd; border-color: #ffeaa7;">
        <h3>üîç URL Monitor - Set Weekly URL to Check</h3>
        <p>Set the QB rankings URL to monitor for timestamp changes. The system will check every hour and notify you when Boone updates his rankings.</p>
        
        <div style="margin-bottom: 10px;">
            <label>Week Number: <input type="number" id="monitor-week" min="1" max="18" value="1" style="width: 60px; margin-left: 10px;"></label>
        </div>
        
        <div style="margin-bottom: 10px;">
            <label>QB Rankings URL:</label>
            <input type="url" id="monitor-url" placeholder="https://sports.yahoo.com/fantasy/article/..." style="width: 100%; margin-top: 5px;">
        </div>
        
        <button onclick="setMonitorUrl()" style="background: #28a745;">üìù Set Monitor URL</button>
        <button onclick="checkNow()" style="background: #007cba;">üîç Check Now</button>
        
        <div id="monitor-status" style="margin-top: 15px; padding: 10px; border-radius: 4px; background: #f8f9fa;">
            <div><strong>Status:</strong> <span id="status-text">Not monitoring</span></div>
            <div><strong>Current URL:</strong> <span id="current-url">None set</span></div>
            <div><strong>Last Check:</strong> <span id="last-check">Never</span></div>
            <div><strong>Article Timestamp:</strong> <span id="article-timestamp">Unknown</span></div>
            <div id="update-alert" style="margin-top: 10px;"></div>
        </div>
    </div>

    <div class="instructions">
        <strong>Instructions:</strong>
        <ol>
            <li>Copy rankings from Yahoo Sports articles (just the player names and opponents)</li>
            <li>Paste one player per line in format: "Player Name vs OPP" or "Player Name @ OPP"</li>
            <li>Click "Generate JSON" to create the rankings data</li>
            <li>Copy the JSON output and save as <code>rankings.json</code> in your project</li>
        </ol>
        <p><strong>Example format:</strong><br>
        Josh Allen vs ARI<br>
        Lamar Jackson @ KC<br>
        Patrick Mahomes vs CIN</p>
    </div>

    <div class="grid">
        <div class="position-section">
            <h3>Quarterbacks (QB)</h3>
            <textarea id="qb" placeholder="Paste QB rankings here...&#10;Josh Allen vs ARI&#10;Lamar Jackson @ KC&#10;Patrick Mahomes vs CIN"></textarea>
        </div>

        <div class="position-section">
            <h3>Running Backs (RB)</h3>
            <textarea id="rb" placeholder="Paste RB rankings here...&#10;Christian McCaffrey vs GB&#10;Josh Jacobs @ MIN&#10;Saquon Barkley vs LAR"></textarea>
        </div>

        <div class="position-section">
            <h3>Wide Receivers (WR)</h3>
            <textarea id="wr" placeholder="Paste WR rankings here...&#10;Ja'Marr Chase @ KC&#10;Tyreek Hill vs BUF&#10;Cooper Kupp @ PHI"></textarea>
        </div>

        <div class="position-section">
            <h3>Tight Ends (TE)</h3>
            <textarea id="te" placeholder="Paste TE rankings here...&#10;Travis Kelce vs CIN&#10;Mark Andrews vs BUF&#10;George Kittle @ NYJ"></textarea>
        </div>

        <div class="position-section">
            <h3>FLEX</h3>
            <textarea id="flex" placeholder="Paste FLEX rankings here...&#10;Christian McCaffrey RB1 vs GB&#10;Ja'Marr Chase WR1 @ KC&#10;Tyler Lockett WR69 @ DEN"></textarea>
        </div>

        <div class="position-section">
            <h3>Defense/ST (DEF)</h3>
            <textarea id="def" placeholder="Paste DEF rankings here...&#10;49ers vs NYJ&#10;Bills @ ARI&#10;Ravens vs KC"></textarea>
        </div>

        <div class="position-section">
            <h3>Kickers (K)</h3>
            <textarea id="k" placeholder="Paste K rankings here...&#10;Justin Tucker vs KC&#10;Harrison Butker @ BAL&#10;Tyler Bass @ ARI"></textarea>
        </div>
    </div>

    <div style="text-align: center; margin: 30px 0;">
        <button onclick="generateJSON()">üìÑ Generate JSON</button>
        <button onclick="clearAll()">üóëÔ∏è Clear All</button>
    </div>

    <div class="output" id="output" style="display: none;">
        <h3>Generated Rankings JSON:</h3>
        <textarea id="json-output" style="height: 400px;" readonly></textarea>
        <br><br>
        <button onclick="copyJSON()">üìã Copy JSON</button>
        <button onclick="downloadJSON()">üíæ Download rankings.json</button>
    </div>

    <script>
        function parsePlayerLine(line, rank) {
            line = line.trim();
            if (!line) return null;
            
            // Remove any leading numbers/rank
            line = line.replace(/^\d+\.?\s*/, '');
            
            // Handle FLEX format: "Tyler Lockett WR69 @ DEN"
            const flexMatch = line.match(/^(.+?)\s+([A-Z]{2}\d+)\s+(vs|@)\s+([A-Z]{2,4})$/i);
            if (flexMatch) {
                return {
                    preGameRank: rank,
                    player: flexMatch[1].trim(),
                    opponent: `${flexMatch[3]} ${flexMatch[4]}`,
                    positionRank: flexMatch[2]  // WR69, RB12, etc.
                };
            }
            
            // Handle standard format: "Josh Allen vs ARI"
            const vsMatch = line.match(/^(.+?)\s+(vs|@)\s+([A-Z]{2,4})$/i);
            if (vsMatch) {
                return {
                    preGameRank: rank,
                    player: vsMatch[1].trim(),
                    opponent: `${vsMatch[2]} ${vsMatch[3]}`
                };
            }
            
            // If no opponent found, just use the player name
            return {
                preGameRank: rank,
                player: line,
                opponent: ''
            };
        }

        function generateJSON() {
            const positions = ['qb', 'rb', 'wr', 'te', 'flex', 'def', 'k'];
            const rankings = {};
            
            let hasData = false;
            
            positions.forEach(pos => {
                const textarea = document.getElementById(pos);
                const lines = textarea.value.split('\n').filter(line => line.trim());
                
                if (lines.length > 0) {
                    hasData = true;
                    rankings[pos] = lines.map((line, index) => parsePlayerLine(line, index + 1)).filter(Boolean);
                }
            });
            
            if (!hasData) {
                alert('Please enter rankings for at least one position');
                return;
            }
            
            const jsonOutput = JSON.stringify(rankings, null, 2);
            document.getElementById('json-output').value = jsonOutput;
            document.getElementById('output').style.display = 'block';
            document.getElementById('json-output').scrollIntoView({ behavior: 'smooth' });
        }

        function clearAll() {
            if (confirm('Clear all entered rankings?')) {
                const positions = ['qb', 'rb', 'wr', 'te', 'flex', 'def', 'k'];
                positions.forEach(pos => {
                    document.getElementById(pos).value = '';
                });
                document.getElementById('output').style.display = 'none';
            }
        }

        function copyJSON() {
            const jsonOutput = document.getElementById('json-output');
            jsonOutput.select();
            document.execCommand('copy');
            alert('JSON copied to clipboard!');
        }

        function downloadJSON() {
            const jsonContent = document.getElementById('json-output').value;
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'rankings.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Store monitor config on server via API
        async function setMonitorUrl() {
            const weekNumber = document.getElementById('monitor-week').value;
            const url = document.getElementById('monitor-url').value;

            if (!weekNumber || !url) {
                alert('Please enter both week number and URL');
                return;
            }

            try {
                // Call backend API to store the configuration
                const response = await fetch('/.netlify/functions/set-monitor-url', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        weekNumber: parseInt(weekNumber), 
                        qbUrl: url 
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    alert(`‚úÖ Monitor set for Week ${weekNumber}!`);
                    // Also store in localStorage for immediate display
                    const monitorConfig = {
                        active: true,
                        url: url,
                        weekNumber: parseInt(weekNumber),
                        lastCheck: null,
                        articleTimestamp: null,
                        updateAvailable: false,
                        setAt: new Date().toISOString()
                    };
                    localStorage.setItem('boone-monitor-config', JSON.stringify(monitorConfig));
                    updateMonitorDisplay(monitorConfig);
                } else {
                    alert('‚ùå Failed to set monitor: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                alert('‚ùå Network error: ' + error.message);
            }
        }

        async function checkNow() {
            const stored = localStorage.getItem('boone-monitor-config');
            if (!stored) {
                alert('‚ùå No URL configured. Please set a URL first.');
                return;
            }

            const config = JSON.parse(stored);
            document.getElementById('status-text').textContent = 'Checking...';
            
            try {
                // Call the manual check function with the stored URL
                const response = await fetch('/.netlify/functions/manual-monitor-check', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ qbUrl: config.url })
                });

                const data = await response.json();
                
                if (data.success) {
                    // Update stored config with check results
                    config.lastCheck = new Date().toISOString();
                    config.articleTimestamp = data.articleTimestamp;
                    config.updateAvailable = data.updateAvailable;
                    
                    localStorage.setItem('boone-monitor-config', JSON.stringify(config));
                    
                    if (data.updateAvailable) {
                        showUpdateAlert(`‚ö†Ô∏è UPDATE AVAILABLE! Boone updated rankings at ${new Date(data.articleTimestamp).toLocaleString()}. Time to copy/paste new rankings!`);
                    } else {
                        showUpdateAlert('‚úÖ No update needed - you\'re current!', 'success');
                    }
                    
                    updateMonitorDisplay(config);
                } else {
                    alert('‚ùå Check failed: ' + (data.error || 'Unknown error'));
                    document.getElementById('status-text').textContent = config.active ? 'Active - Checking hourly' : 'Not monitoring';
                }
            } catch (error) {
                alert('‚ùå Network error: ' + error.message);
                document.getElementById('status-text').textContent = config.active ? 'Active - Checking hourly' : 'Not monitoring';
            }
        }

        async function loadMonitorStatus() {
            try {
                console.log('Loading monitor status from backend...');
                
                // First try to get from backend
                const response = await fetch('/.netlify/functions/monitor-status');
                const data = await response.json();
                
                if (data.success && data.monitor) {
                    console.log('Monitor status loaded from backend:', data.monitor);
                    updateMonitorDisplay(data.monitor);
                    // Also sync to localStorage for offline viewing
                    localStorage.setItem('boone-monitor-config', JSON.stringify(data.monitor));
                } else {
                    console.log('Backend has no monitor config, checking localStorage...');
                    // Fallback to localStorage
                    const stored = localStorage.getItem('boone-monitor-config');
                    if (stored) {
                        const config = JSON.parse(stored);
                        console.log('Using localStorage fallback:', config);
                        updateMonitorDisplay(config);
                    } else {
                        console.log('No monitor config found anywhere');
                        updateMonitorDisplay({
                            active: false,
                            url: null,
                            weekNumber: null,
                            lastCheck: null,
                            articleTimestamp: null,
                            updateAvailable: false,
                            error: 'No configuration found - set a URL first'
                        });
                    }
                }
            } catch (error) {
                console.error('Failed to load monitor status from backend, trying localStorage...', error);
                // Fallback to localStorage if backend is unavailable
                const stored = localStorage.getItem('boone-monitor-config');
                if (stored) {
                    const config = JSON.parse(stored);
                    updateMonitorDisplay(config);
                } else {
                    updateMonitorDisplay({
                        active: false,
                        url: null,
                        weekNumber: null,
                        lastCheck: null,
                        articleTimestamp: null,
                        updateAvailable: false,
                        error: 'Backend unavailable and no local config found'
                    });
                }
            }
        }

        function updateMonitorDisplay(monitor) {
            document.getElementById('status-text').textContent = monitor.active ? 'Active - Checking hourly' : 'Not monitoring';
            document.getElementById('current-url').textContent = monitor.url || 'None set';
            document.getElementById('last-check').textContent = monitor.lastCheck ? new Date(monitor.lastCheck).toLocaleString() : 'Never';
            document.getElementById('article-timestamp').textContent = monitor.articleTimestamp || 'Unknown';
            
            if (monitor.updateAvailable) {
                showUpdateAlert('‚ö†Ô∏è UPDATE NEEDED! Boone has updated his rankings. Time to copy/paste!');
            } else if (monitor.active) {
                showUpdateAlert('‚úÖ Up to date', 'success');
            }
        }

        function showUpdateAlert(message, type = 'warning') {
            const alertDiv = document.getElementById('update-alert');
            const bgColor = type === 'success' ? '#d4edda' : '#fff3cd';
            const textColor = type === 'success' ? '#155724' : '#856404';
            
            alertDiv.innerHTML = `<div style="background: ${bgColor}; color: ${textColor}; padding: 10px; border-radius: 4px; font-weight: bold;">${message}</div>`;
        }

        // Browser notification support
        let lastKnownTimestamp = null;
        let notificationsEnabled = false;

        function requestNotificationPermission() {
            if ('Notification' in window) {
                Notification.requestPermission().then(permission => {
                    notificationsEnabled = permission === 'granted';
                    if (notificationsEnabled) {
                        showUpdateAlert('‚úÖ Browser notifications enabled!', 'success');
                    }
                });
            }
        }

        function sendBrowserNotification(weekNumber, timestamp) {
            if (notificationsEnabled && 'Notification' in window) {
                new Notification(`üö® Boone Rankings Update!`, {
                    body: `Week ${weekNumber} rankings updated at ${new Date(timestamp).toLocaleString()}`,
                    icon: '/favicon.ico',
                    tag: 'boone-update',
                    requireInteraction: true
                });
            }
        }

        function checkForUpdatesInStatus(monitor) {
            if (monitor.updateAvailable && monitor.articleTimestamp && monitor.articleTimestamp !== lastKnownTimestamp) {
                // New update detected!
                sendBrowserNotification(monitor.weekNumber || 'Unknown', monitor.articleTimestamp);
                lastKnownTimestamp = monitor.articleTimestamp;
            }
        }

        function updateMonitorDisplay(monitor) {
            console.log('Updating display with monitor data:', monitor);
            
            const statusElement = document.getElementById('status-text');
            const urlElement = document.getElementById('current-url');
            const checkElement = document.getElementById('last-check');
            const timestampElement = document.getElementById('article-timestamp');
            
            if (statusElement) statusElement.textContent = monitor.active ? 'Active - Checking hourly' : 'Not monitoring';
            if (urlElement) urlElement.textContent = monitor.url || 'None set';
            if (checkElement) checkElement.textContent = monitor.lastCheck ? new Date(monitor.lastCheck).toLocaleString() : 'Never';
            if (timestampElement) timestampElement.textContent = monitor.articleTimestamp || 'Unknown';
            
            console.log('Display updated - Status:', monitor.active ? 'Active' : 'Not monitoring');
            console.log('Display updated - URL:', monitor.url || 'None set');
            
            // Check for new updates for browser notifications
            checkForUpdatesInStatus(monitor);
            
            if (monitor.updateAvailable) {
                showUpdateAlert('‚ö†Ô∏è UPDATE NEEDED! Boone has updated his rankings. Time to copy/paste!');
            } else if (monitor.active) {
                showUpdateAlert('‚úÖ Up to date', 'success');
            }
        }

        // Load monitor status on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadMonitorStatus();
            // Auto-refresh status every 30 seconds
            setInterval(loadMonitorStatus, 30000);
            
            // Request notification permission if supported
            if ('Notification' in window && Notification.permission === 'default') {
                setTimeout(() => {
                    if (confirm('Enable browser notifications for ranking updates?')) {
                        requestNotificationPermission();
                    }
                }, 2000);
            } else if (Notification.permission === 'granted') {
                notificationsEnabled = true;
            }
        });
    </script>
</body>
</html>